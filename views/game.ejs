<div class="game-page">
  <div class="game-top-bar">
    <div>Score: <span id="score">0</span></div>
    <div>
      Mejor: <span id="bestScore">0</span>
      <span id="bestBadge" class="best-badge hidden">Â¡Nuevo rÃ©cord! ðŸŽ‰</span>
    </div>
  </div>

  <div class="game-wrapper">
    <canvas id="gameCanvas" width="900" height="400"></canvas>
  </div>

  <div class="game-bottom-bar">
    <button id="startButton" class="game-btn">Jugar / Reiniciar</button>

  </button>

    <span class="game-tip">
      Controles: clic o barra espaciadora para saltar. Tienes <strong>1 sola vida</strong>.
    </span>
  </div>
</div>

<style>
  .game-page {
    max-width: 1000px;
    margin: 1.5rem auto 3rem;
    padding: 1.5rem;
    border-radius: 24px;
    background: radial-gradient(circle at top, #1e293b, #020617);
    box-shadow: 0 24px 60px rgba(15, 23, 42, 0.9);
    color: #e5e7eb;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  }

  .game-top-bar {
    display: flex;
    justify-content: space-between;
    font-size: 0.95rem;
    margin-bottom: 0.75rem;
    padding: 0 0.25rem;
    color: #e5e7eb;
  }

  .best-badge {
    margin-left: 0.5rem;
    padding: 0.15rem 0.5rem;
    border-radius: 999px;
    font-size: 0.8rem;
    background: linear-gradient(135deg, #fbbf24, #f97316);
    color: #111827;
    box-shadow: 0 0 18px rgba(251, 191, 36, 0.6);
  }

  .hidden {
    display: none;
  }

  .game-wrapper {
    border-radius: 18px;
    overflow: hidden;
    background: #020617;
    border: 1px solid rgba(148, 163, 184, 0.4);
  }

  #gameCanvas {
    display: block;
    width: 100%;
    height: auto;
    background: radial-gradient(circle at top, #020617, #020617 40%, #022c22 70%, #065f46 100%);
  }

  .game-bottom-bar {
    margin-top: 1rem;
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    align-items: center;
    justify-content: space-between;
    font-size: 0.85rem;
  }

  .game-btn {
    padding: 0.7rem 1.5rem;
    border-radius: 999px;
    border: none;
    font-size: 0.95rem;
    font-weight: 600;
    cursor: pointer;
    background: linear-gradient(135deg, #facc15, #f97316);
    color: #111827;
    box-shadow: 0 12px 28px rgba(248, 181, 32, 0.65);
    transition: transform 0.15s ease, box-shadow 0.15s ease;
  }

  .game-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 16px 32px rgba(248, 181, 32, 0.85);
  }

  .game-tip {
    opacity: 0.85;
  }

  @media (max-width: 768px) {
    .game-page {
      margin: 1rem;
      padding: 1rem;
    }
    .game-bottom-bar {
      flex-direction: column;
      align-items: flex-start;
    }
  }
</style>

<script>
  (function () {
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const scoreSpan = document.getElementById("score");
    const bestScoreSpan = document.getElementById("bestScore");
    const bestBadge = document.getElementById("bestBadge");
    const startButton = document.getElementById("startButton");

    // TamaÃ±o base (usamos esto para escalado si el canvas cambia de tamaÃ±o en CSS)
    const BASE_WIDTH = 900;
    const BASE_HEIGHT = 400;

    // Estado del juego
    let gameState = "idle"; // idle | running | over
    let score = 0;
    let bestScore = 0;

    // Intentar cargar mejor score desde localStorage
    if (window.localStorage) {
      const stored = localStorage.getItem("farmBestScore");
      if (stored) {
        bestScore = parseInt(stored, 10) || 0;
        bestScoreSpan.textContent = bestScore;
      }
    }

    // Pollito
    const player = {
      x: 150,
      y: BASE_HEIGHT / 2,
      radius: 16,
      vy: 0
    };

    // FÃ­sica
    const gravity = 0.20;
    const jumpStrength = -7;

    // ObstÃ¡culos (tubos)
    const pipes = [];
    const pipeWidth = 70;
    const pipeGap = 140;
    const pipeSpeed = 3;
    const pipeInterval = 1500; // ms
    let lastPipeTime = 0;

    let lastFrameTime = 0;

    function resetGame() {
      gameState = "running";
      score = 0;
      scoreSpan.textContent = score.toString();
      bestBadge.classList.add("hidden");

      player.y = BASE_HEIGHT / 2;
      player.vy = 0;

      pipes.length = 0;
      lastPipeTime = performance.now();
      lastFrameTime = performance.now();
    }

    function spawnPipe() {
      const minGapY = 80;
      const maxGapY = BASE_HEIGHT - 80 - pipeGap;
      const gapY = Math.random() * (maxGapY - minGapY) + minGapY;

      pipes.push({
        x: BASE_WIDTH + 20,
        gapY
      });
    }

    function update(dt) {
      if (gameState !== "running") return;

      // Actualizar fÃ­sica del pollito
      player.vy += gravity;
      player.y += player.vy;

      // Generar tubos
      const now = performance.now();
      if (now - lastPipeTime > pipeInterval) {
        spawnPipe();
        lastPipeTime = now;
      }

      // Mover tubos
      for (let i = pipes.length - 1; i >= 0; i--) {
        pipes[i].x -= pipeSpeed;

        // Incrementar score cuando el tubo pasa al pollito
        if (!pipes[i].counted && pipes[i].x + pipeWidth < player.x) {
          pipes[i].counted = true;
          score++;
          scoreSpan.textContent = score.toString();
        }

        // Eliminar tubos fuera de pantalla
        if (pipes[i].x + pipeWidth < 0) {
          pipes.splice(i, 1);
        }
      }

      // Colisiones: suelo/techo
      if (player.y + player.radius >= BASE_HEIGHT - 20 || player.y - player.radius <= 0) {
        endGame();
        return;
      }

      // Colisiones con tubos
      for (const pipe of pipes) {
        const withinX = player.x + player.radius > pipe.x && player.x - player.radius < pipe.x + pipeWidth;
        const aboveGap = player.y - player.radius < pipe.gapY;
        const belowGap = player.y + player.radius > pipe.gapY + pipeGap;

        if (withinX && (aboveGap || belowGap)) {
          endGame();
          return;
        }
      }
    }

    function endGame() {
      if (gameState === "over") return;
      gameState = "over";

      // 1 sola vida â†’ fin inmediato
      if (score > bestScore) {
        bestScore = score;
        bestScoreSpan.textContent = bestScore.toString();
        bestBadge.classList.remove("hidden");

        if (window.localStorage) {
          localStorage.setItem("farmBestScore", bestScore.toString());
        }
      }
    }

    function drawBackground() {
      // Fondo ya lo hace el CSS, pero dibujamos una "lÃ­nea de suelo"
      ctx.fillStyle = "#064e3b";
      ctx.fillRect(0, BASE_HEIGHT - 20, BASE_WIDTH, 20);
    }

    function drawPlayer() {
      const { x, y, radius } = player;

      // cuerpo
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fillStyle = "#facc15";
      ctx.fill();

      // borde suave
      ctx.strokeStyle = "rgba(250, 204, 21, 0.8)";
      ctx.lineWidth = 3;
      ctx.stroke();

      // ojo
      ctx.beginPath();
      ctx.arc(x + 6, y - 4, 5, 0, Math.PI * 2);
      ctx.fillStyle = "#ffffff";
      ctx.fill();

      ctx.beginPath();
      ctx.arc(x + 7, y - 4, 2.4, 0, Math.PI * 2);
      ctx.fillStyle = "#0f172a";
      ctx.fill();

      // pico
      ctx.beginPath();
      ctx.moveTo(x + radius, y + 2);
      ctx.lineTo(x + radius + 8, y + 0);
      ctx.lineTo(x + radius, y - 2);
      ctx.closePath();
      ctx.fillStyle = "#f97316";
      ctx.fill();
    }

    function drawPipes() {
      for (const pipe of pipes) {
        ctx.fillStyle = "#0f172a";
        ctx.fillRect(pipe.x, 0, pipeWidth, pipe.gapY);
        ctx.fillRect(pipe.x, pipe.gapY + pipeGap, pipeWidth, BASE_HEIGHT - (pipe.gapY + pipeGap));

        // bordes
        ctx.strokeStyle = "#1f2937";
        ctx.lineWidth = 2;
        ctx.strokeRect(pipe.x, 0, pipeWidth, pipe.gapY);
        ctx.strokeRect(pipe.x, pipe.gapY + pipeGap, pipeWidth, BASE_HEIGHT - (pipe.gapY + pipeGap));
      }
    }

    function drawStateOverlay() {
      if (gameState === "idle") {
        drawCenteredText("Pulsa Jugar para comenzar", BASE_HEIGHT / 2 - 10);
        drawCenteredText("Clic o espacio para saltar", BASE_HEIGHT / 2 + 20, 14);
      } else if (gameState === "over") {
        drawCenteredText("Game Over", BASE_HEIGHT / 2 - 10, 26);
        drawCenteredText("Pulsa Jugar para intentarlo de nuevo", BASE_HEIGHT / 2 + 20, 14);
      }
    }

    function drawCenteredText(text, y, size = 18) {
      ctx.fillStyle = "#e5e7eb";
      ctx.font = `bold ${size}px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;
      ctx.textAlign = "center";
      ctx.fillText(text, BASE_WIDTH / 2, y);
      ctx.textAlign = "left";
    }

    function gameLoop(timestamp) {
      const dt = timestamp - lastFrameTime;
      lastFrameTime = timestamp;

      ctx.clearRect(0, 0, BASE_WIDTH, BASE_HEIGHT);

      drawBackground();
      update(dt);
      drawPipes();
      drawPlayer();
      drawStateOverlay();

      requestAnimationFrame(gameLoop);
    }

    function handleJump() {
      if (gameState === "idle") return;
      if (gameState === "over") return;
      player.vy = jumpStrength;
    }

    // Eventos
    startButton.addEventListener("click", () => {
      resetGame();
    });

    window.addEventListener("keydown", (e) => {
      if (e.code === "Space") {
        e.preventDefault();
        if (gameState === "idle") return;
        if (gameState === "over") return;
        handleJump();
      }
    });

    canvas.addEventListener("mousedown", () => {
      if (gameState !== "running") return;
      handleJump();
    });

    // Empezamos en modo "idle" y lanzamos el loop
    lastFrameTime = performance.now();
    requestAnimationFrame(gameLoop);
  })();
</script>
